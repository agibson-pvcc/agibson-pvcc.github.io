<!--
Aaron Gibson
Chapter 2-3 Program
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Chapter 2 and 3</title>
    <style>
        body {
            background-color: rgb(0, 0, 0);   
            color: white;
            font-family: Arial, sans-serif;
            min-height: 100vh;        
            margin: 0;
            padding: 20px;
        }

        table {
            border-collapse: collapse;
            background-color: #111; 
            width: calc(100% - 80px);
            margin: 20px;             
            box-shadow: 0 0 20px rgb(0, 0, 0);
            counter-reset: row; 
        }        

        td {
            color: rgb(87, 255, 235);
            background-color: rgb(13, 0, 48);
            border: 0.5px solid white;
            padding: 10px 15px;
            text-align: left;
            vertical-align: top;
            box-shadow: 0 0 5px white, 0 0 10px rgb(0, 0, 0);
        }

        /* Automatically number each row in the table */
        tr.row-item td::before {
            counter-increment: row;
            content: counter(row) ". ";
            display: inline-block;
            width: 2.2em;
            text-align: right;
            margin-right: 8px;
            font-weight: bold;
            color: rgb(255, 8, 251);
        }

        ol {
            margin: 5px 0 15px 25px;
            padding: 0;
        }

        ul {
            margin: 5px 0 10px 40px; 
            padding-left: 20px;       
        }
        

        strong {
            font-size: 120%;
        }

        .title {
            color: rgb(179, 0, 255);
            font-weight: bold;
            font-size: 160%;
            margin-top: 10px;
        }

        .name{
            color: rgb(255, 0, 0);
        }
    </style>
</head>
<body>
    
    <table>
        <tr><td class="title">Chapter 2: Algorithm Discovery and Design</td></tr>
        <tr><td class="title">Chapter 3: The Efficiency of Algorithms</td></tr>
        <tr><td class="name">Student: Aaron Gibson</td></tr>
    </table>

    <table>
        <tr><td><strong>Chapter 2: Algorithms</strong></td></tr>
        <tr class="row-item"><td>Natural language is unfit for describing algorithms because of the verbose nature of it, the lack of structure, and difficulty following along.</td></tr>
        <tr class="row-item"><td>Problem Item #1 algorithm: <br>
            set int a to grade 1 <br>
            set int b to grade 2 <br>
            set int c to grade 3 <br>
            set int sum to (a + b + c) <br>
            set float average to (sum / 3)            
        </td></tr>
        <tr class="row-item"><td>Problem Item #2 algorithm: <br>
            set int previousMileage to previous mileage of car <br>
            set int currentMileage to current mileage of car <br> 
            set int gallonsOfGas to amount of gas filled up in car <br> 
            set int distance to (currentMileage - previousMileage) <br>
            set float milesPerGallon to (distance / gallonsOfGas)            
        </td></tr>
    </table>

    <table>
        <tr><td><strong>Chapter 2: Briefly Define: </strong></td></tr>
        <tr class="row-item"><td>Natural Language 
            <ul><li>Natural language, the language we speak and write in our everyday lives. This could be English, Spanish, Arabic, Japanese, Swahili,
                or any language.
            </li></ul>
        </td></tr>
        <tr class="row-item"><td>Pseudocode
            <ul><li>A set of English-language constructs designed to more or less resemble statements in a programming language but that
                do not actually run on a computer. Pseudocode represents a compromise
                between the two extremes of natural and formal languages.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Sequential Operation (Straight line algorithm): 
            <ul><li>A sequential instruction carries out a single well defined task. When that task is finished, the algorithm moves on to the
                next operation. Sequential operations are usually expressed as simple declarative sentences.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Input: 
            <ul><li>Input operations provide the computing agent with data values from the outside world that it may then use in later instructions.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Output: 
            <ul><li>Output operations send results from the computing agent to the outside world. </li></ul>
        </td></tr>
        <tr class="row-item"><td>Conditional Statement: 
            <ul><li>Conditional statements are the “question-asking” operations of an
                algorithm. They allow an algorithm to ask a yes/no question and select the
                next operation to perform on the basis of the answer to that question. There
                are a number of ways to phrase a question, but the most common conditional
                statement is the if/then/else statement</li></ul>
        </td></tr>
        <tr class="row-item"><td>Boolean Condition: 
            <ul><li>A boolean condition is an expression that evaluates to either true or false. It's often used in decision-making (like if statements, loops, comparisons).</li></ul>
        </td></tr>
        <tr class="row-item"><td>Algorithmic Discovery Process
            <ul><li>The algorithmic discovery process is the method of designing 
                and refining a sequence of instructions to solve a specific problem.</li></ul>
        </td></tr>
    </table>

    <table>
        <tr><td><strong>Chapter 3: Briefly describe or define</strong></td></tr>
        <tr class="row-item"><td>Why algorithms should be correct
            <ul><li>The algorithms designed and
                implemented by computer scientists are intended to solve important real world problems, and they must
                accomplish that task in a correct and reasonably efficient manner. Otherwise they are not of much use to their intended
                audience.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Why algorithms should be efficient 
            <ul><li>Our brute force chess example illustrates that it is not enough simply
                to develop a correct algorithm; we also want a solution that is efficient and
                that produces the desired result in a reasonable amount of time. (Would
                you want to market a chess-playing program that takes 1025 years to make
                its first move?)</li></ul>
        </td></tr>
        <tr class="row-item"><td>Program Maintenance
            <ul><li>A great deal of
                time and money are devoted to program maintenance. The person who has to
                modify a program, either to correct errors or to expand its functionality, often
                is not the person who wrote the original program. To make program maintenance as easy as possible, the algorithm the program uses should be easy to
                understand. Ease of understanding, clarity, “ease of handling”—whatever you
                want to call it—is a highly desirable characteristic of an algorithm.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Importance of algorithm: ease of understanding
            <ul><li>Ease of understanding, clarity, “ease of handling”—whatever you
                want to call it—is a highly desirable characteristic of an algorithm.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Algorithmic elegance
            <ul><li>Elegance is the algorithmic equivalent of style.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Sequential search algorithm
            <ul><li>The sequential search algorithm solves a very common problem: searching
                a list of items to locate a particular item. Another very common problem is
                that of sorting a list of items into order—either alphabetical or numerical
                order.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Order of magnitude
            <ul><li>Order of magnitude is an estimate of an algorithm's efficiency, 
                showing how its running time or space grows relative to input size, usually expressed in Big-O notation.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Selection sort
            <ul><li>Selection sort is one sorting algorithm. An algorithm such as selection sort has the advantage
                 of being relatively easy to understand. If the size of the list, n, is fairly
                small, then an easy-to-understand algorithm might be preferable to one that
                is more efficient but more obscure.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Flop: Floating point operation
            <ul><li>One way to compare performance among different makes of computers is to
                give the number of arithmetic operations, such as additions or subtractions of
                real numbers, that each one can do in 1 second. These operations are called
                floating-point operations, and computers are often compared in terms of the
                number of flops (floating-point operations per second) they can crank out.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Teraflop
            <ul><li>A measure of computing speed equal to one trillion (10¹²) floating-point operations per second. </li></ul>
        </td></tr>
        <tr class="row-item"><td>Petaflop
            <ul><li>A measure of computing speed equal to one quadrillion (10¹⁵) floating-point operations per second.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Parallel processor
            <ul><li>Computers with multiple processors that work simultaneously on different parts of a task to complete computations faster.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Data clean up
            <ul><li>The process of correcting errors or
                inaccuracies in a dataset to make it accurate and usable for processing.
            </li></ul>
        </td></tr>
        <tr class="row-item"><td>Binary search algorithm
            <ul><li>An efficient method for finding a target value in a sorted list by repeatedly 
                dividing the search range in half until the value is found or the range is empty.</li></ul>
        </td></tr>
        <tr class="row-item"><td>Pattern matching 
            <ul><li>The process
                of searching for a special pattern of symbols within a larger collection of
                information is called pattern matching. Most good word processors provide
                this service as a menu item called Find or something similar. Furthermore,
                most web search engines try to match your search terms to the keywords
                that appear on a webpage.
                Pattern matching can be applied to almost any kind of information,
                including graphics, sound, and photographs.</li></ul>
        </td></tr>                            
    </table>

    <table>
        <tr><td><strong>Karl Friedrich Gauss</strong></td></tr>
        <tr class="row-item"><td>Brief overview of Karl Friedrich Gauss' mathematics abilities and scientific achievements:
            <ul><li>Gauss was noticed at a young age for his abilities. He was known for performing complex calculations in his head. 
                Later in his career he was recognized for discovering Bode's law, the binomial theorem and the arithmetic-geometric mean, 
                as well as the law of quadratic reciprocity and the prime number theorem. </li></ul>
        </td></tr>
        <tr class="row-item"><td>Describe Karl Friedrich Gauss' algorithm for adding up the numbers from 1 to 100:
            <ul><li>Gauss realized that instead of adding up each number chronologically, you could separate them into the lowest and highest numbers from 1-100. Each pair would equal 101, and there are 50 pairs. Once you realize that, it's as simple as 50 pairs multiplied by 101, which equates to 5050.</li></ul>
        </td></tr>
        <tr class="row-item"><td>What are gaussian optics?
            <ul><li>It is the term to describe an optical phenomena dealing with paraxial approximation. It is used to look at how light propagates through lenses and mirrors.</li></ul>
        </td></tr>
        <tr class="row-item"><td>What is a "gaussian blur" and how is it used in digital image editing?
            <ul><li>The Gaussian Blur is a formula used for blurring digital images. It essentially reduces the detail in the image to create a softer blurred effect.
                It is used in digital imaging for several purposes such as blurring backgrounds to make the foreground pop. </li>
                <img src="blurBefore.jpeg" alt="Gaussian Before Blur" width="400">
                <img src="blurAfter.jpeg" alt="Gaussian After Blur" width="400" style="transform: rotate(180deg);">
            </ul>
        </td></tr>

        <tr class="row-item"><td>Resources
        <ul>
            <li>https://www.britannica.com/biography/Carl-Friedrich-Gauss</li>
            <li>https://mathshistory.st-andrews.ac.uk/Biographies/Gauss/</li>
            <li>https://www.sciencedirect.com/topics/engineering/gaussian-blur</li>
        </ul>
        </td></tr>
    </table>

</body>
</html>
